#!/usr/bin/env python3
"""
Dynamic Column Discovery Module
Handles automatic discovery and mapping of table columns for BigQuery validation scenarios.
"""

import logging
from typing import Dict, List, Optional, Set, Any
from google.cloud import bigquery
import streamlit as st

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DynamicColumnManager:
    """Manages dynamic column discovery and mapping for BigQuery tables."""
    
    def __init__(self, project_id: str, dataset_id: str):
        """Initialize the column manager with project and dataset information."""
        self.project_id = project_id
        self.dataset_id = dataset_id
        self.table_schemas = {}
        self.column_mappings = {}
        self._initialize_default_mappings()
    
    def _initialize_default_mappings(self):
        """Initialize default column mappings for common scenarios."""
        # Default column name variations
        self.default_mappings = {
            'first_name': ['first_name', 'firstname', 'fname', 'given_name'],
            'last_name': ['last_name', 'lastname', 'lname', 'surname', 'family_name'],
            'full_name': ['full_name', 'fullname', 'name', 'customer_name', 'account_holder'],
            'address': ['address', 'street_address', 'full_address', 'location'],
            'email': ['email', 'email_address', 'contact_email'],
            'phone': ['phone', 'phone_number', 'contact_phone', 'mobile'],
            'customer_id': ['customer_id', 'cust_id', 'id', 'customer_key'],
            'account_id': ['account_id', 'acct_id', 'account_number', 'account_key'],
            'transaction_id': ['transaction_id', 'trans_id', 'txn_id', 'transaction_key'],
            'amount': ['amount', 'transaction_amount', 'txn_amount', 'value'],
            'balance': ['balance', 'account_balance', 'current_balance'],
            'account_type': ['account_type', 'acct_type', 'type'],
            'status': ['status', 'account_status', 'state'],
            'created_date': ['created_date', 'create_date', 'date_created', 'open_date'],
            'transaction_date': ['transaction_date', 'txn_date', 'date', 'trans_date']
        }
    
    def get_table_columns(self, table_name: str) -> List[str]:
        """Get available columns for a table."""
        try:
            # TODO: This should ideally query BigQuery to get actual schema
            # For now, return a reasonable set of columns based on common banking tables
            
            # Different tables may have different schemas
            if 'customer' in table_name.lower():
                return [
                    'customer_id', 'cust_id', 'id',
                    'first_name', 'last_name', 'full_name', 'name',
                    'address', 'email', 'phone', 'status',
                    'created_date', 'account_type'
                ]
            elif 'account' in table_name.lower():
                return [
                    'account_id', 'acct_id', 'id', 'customer_id', 
                    'balance', 'account_type', 'status',
                    'created_date', 'open_date'
                ]
            elif 'transaction' in table_name.lower():
                return [
                    'transaction_id', 'trans_id', 'txn_id', 'id',
                    'account_id', 'customer_id', 'amount', 'transaction_date',
                    'transaction_type', 'status', 'description'
                ]
            else:
                # Generic table - return broader set of possible columns
                common_columns = [
                    'id', 'customer_id', 'account_id', 'transaction_id',
                    'first_name', 'last_name', 'full_name', 'name',
                    'amount', 'balance', 'account_type',
                    'transaction_date', 'created_date',
                    'address', 'email', 'phone', 'status'
                ]
                
                # Store in cache
                self.table_schemas[table_name] = common_columns
                return common_columns
            
        except Exception as e:
            logger.warning(f"Could not fetch schema for table {table_name}: {str(e)}")
            # Return basic fallback columns
            return ['id', 'name', 'value', 'date', 'amount', 'balance']
    
    def get_column_mapping(self, table_name: str) -> Dict[str, str]:
        """Get column mapping for a specific table."""
        if table_name not in self.column_mappings:
            # Create default mapping
            available_columns = self.get_table_columns(table_name)
            mapping = {}
            
            for logical_name, variations in self.default_mappings.items():
                for variation in variations:
                    if variation in available_columns:
                        mapping[logical_name] = variation
                        break
                else:
                    # No exact match found, use logical name if it exists
                    if logical_name in available_columns:
                        mapping[logical_name] = logical_name
            
            self.column_mappings[table_name] = mapping
        
        return self.column_mappings[table_name]
    
    def map_column(self, table_name: str, logical_column: str) -> str:
        """Map a logical column name to actual column name."""
        mapping = self.get_column_mapping(table_name)
        return mapping.get(logical_column, logical_column)
    
    def has_column(self, table_name: str, column_name: str) -> bool:
        """Check if a table has a specific column."""
        available_columns = self.get_table_columns(table_name)
        return column_name.lower() in [col.lower() for col in available_columns]
    
    def get_name_concat_expression(self, table_name: str) -> str:
        """Get SQL expression for concatenating name fields."""
        mapping = self.get_column_mapping(table_name)
        
        # Try to find first_name and last_name
        first_name = mapping.get('first_name')
        last_name = mapping.get('last_name')
        
        if first_name and last_name and self.has_column(table_name, first_name) and self.has_column(table_name, last_name):
            return f'CONCAT({first_name}, " ", {last_name})'
        
        # Try to find full_name
        full_name = mapping.get('full_name')
        if full_name and self.has_column(table_name, full_name):
            return full_name
        
        # Try customer_name or name
        for name_field in ['customer_name', 'name', 'account_holder']:
            if self.has_column(table_name, name_field):
                return name_field
        
        # Fallback
        return '"Unknown Name"'
    
    def _find_table_key(self, table_name: str, preferred_keys: List[str]) -> Optional[str]:
        """Find the best matching key column for a table."""
        available_columns = self.get_table_columns(table_name)
        available_lower = [col.lower() for col in available_columns]
        
        for key in preferred_keys:
            if key.lower() in available_lower:
                # Return the actual column name with original casing
                idx = available_lower.index(key.lower())
                return available_columns[idx]
        
        return None
    
    def get_join_key(self, table_name: str, join_type: str = 'customer') -> str:
        """Get appropriate join key for a table based on context."""
        if join_type == 'customer':
            preferred_keys = ['customer_id', 'cust_id', 'id']
        elif join_type == 'account':
            preferred_keys = ['account_id', 'acct_id', 'account_number', 'id']
        elif join_type == 'transaction':
            preferred_keys = ['transaction_id', 'trans_id', 'txn_id', 'id']
        else:
            preferred_keys = ['id', 'key', f'{table_name}_id']
        
        found_key = self._find_table_key(table_name, preferred_keys)
        return found_key or 'id'  # Default fallback
    
    def debug_table_info(self, table_name: str) -> Dict[str, Any]:
        """Debug method to show what the column manager knows about a table."""
        return {
            'table_name': table_name,
            'available_columns': self.get_table_columns(table_name),
            'column_mapping': self.get_column_mapping(table_name),
            'name_concat_expression': self.get_name_concat_expression(table_name),
            'suggested_join_key': self.get_join_key(table_name)
        }


# Global instance cache
_column_managers = {}


def get_dynamic_column_manager(project_id: str, dataset_id: str) -> DynamicColumnManager:
    """Get or create a dynamic column manager instance."""
    cache_key = f"{project_id}:{dataset_id}"
    
    if cache_key not in _column_managers:
        _column_managers[cache_key] = DynamicColumnManager(project_id, dataset_id)
    
    return _column_managers[cache_key]


def clear_column_manager_cache():
    """Clear the column manager cache."""
    global _column_managers
    _column_managers.clear()


# Additional utility functions for backward compatibility
def get_table_columns(table_name: str, project_id: str, dataset_id: str) -> List[str]:
    """Get available columns for a table - utility function."""
    manager = get_dynamic_column_manager(project_id, dataset_id)
    return manager.get_table_columns(table_name)


def get_column_mapping(table_name: str, project_id: str, dataset_id: str) -> Dict[str, str]:
    """Get column mapping for a table - utility function."""
    manager = get_dynamic_column_manager(project_id, dataset_id)
    return manager.get_column_mapping(table_name)


def map_column_name(table_name: str, logical_column: str, project_id: str, dataset_id: str) -> str:
    """Map logical column to actual column - utility function."""
    manager = get_dynamic_column_manager(project_id, dataset_id)
    return manager.map_column(table_name, logical_column)
